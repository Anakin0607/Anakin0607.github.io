<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"anakin0607.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="用暴力-&gt;优化的思想解决大部分力扣题">
<meta property="og:type" content="article">
<meta property="og:title" content="暴力算法">
<meta property="og:url" content="https://anakin0607.github.io/%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Anakin0607">
<meta property="og:description" content="用暴力-&gt;优化的思想解决大部分力扣题">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-19T06:34:34.000Z">
<meta property="article:modified_time" content="2024-09-26T09:29:12.268Z">
<meta property="article:author" content="Anakin">
<meta property="article:tag" content="Leetcode">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://anakin0607.github.io/%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://anakin0607.github.io/%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95/","path":"暴力算法/","title":"暴力算法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>暴力算法 | Anakin0607</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Anakin0607</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">8</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">9</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9A%B4%E5%8A%9B"><span class="nav-number">1.</span> <span class="nav-text">1.什么是暴力</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">2.</span> <span class="nav-text">2. 暴力解的意义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E9%99%8D%E4%BD%8E%E9%97%AE%E9%A2%98%E9%9A%BE%E5%BA%A6"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 降低问题难度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%B9%B3%E7%A8%B3%E8%80%83%E8%AF%95%E5%BF%83%E6%80%81"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 平稳考试心态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E9%AA%8C%E8%AF%81%E6%80%9D%E8%B7%AF"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 验证思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E4%B9%A6%E5%86%99%E6%9A%B4%E5%8A%9B%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">3. 书写暴力解的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1.两数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2.反转字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-%E8%BD%A6%E5%8E%A2%E9%87%8D%E7%BB%84"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3 车厢重组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-2%E7%9A%84%E5%B9%82"><span class="nav-number">3.1.4.</span> <span class="nav-text">3.1.4 2的幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-%E5%85%B6%E4%BB%96%E4%B9%A0%E9%A2%98"><span class="nav-number">3.1.5.</span> <span class="nav-text">3.1.4 其他习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E9%80%92%E5%BD%92"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 斐波那契数列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%80%BB%E7%BB%93"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E9%AB%98%E7%BA%A7%E6%9A%B4%E5%8A%9B"><span class="nav-number">4.</span> <span class="nav-text">4. 高级暴力</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E5%87%8F%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 减而治之</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B1%EF%BC%9A%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.1.1.</span> <span class="nav-text">例1：反转字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B2%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">4.1.2.</span> <span class="nav-text">例2：选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B3%EF%BC%9A%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="nav-number">4.1.3.</span> <span class="nav-text">例3：汉诺塔问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B4-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">4.1.4.</span> <span class="nav-text">例4:全排列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 分而治之</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B1-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">4.2.1.</span> <span class="nav-text">例1.归并排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E6%90%9C%E7%B4%A2"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 动态规划（记忆化搜索）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E4%BC%98%E5%8C%96%E6%9A%B4%E5%8A%9B%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">5. 优化暴力解的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 评估指标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.1 时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.2 空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E5%8E%BB%E9%87%8D"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 去重</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0"><span class="nav-number">5.2.1.</span> <span class="nav-text">4.2.1 子数组最大平均数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2%E6%9F%A5%E6%89%BE%E6%80%BB%E4%BB%B7%E6%A0%BC%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%95%86%E5%93%81"><span class="nav-number">5.2.2.</span> <span class="nav-text">4.2.2查找总价格为目标值的商品</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-%E9%93%BE%E8%A1%A8"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-%E6%A0%91"><span class="nav-number">5.3.3.</span> <span class="nav-text">5.3.3 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-4-%E5%9B%BE"><span class="nav-number">5.3.4.</span> <span class="nav-text">5.3.4 图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-5-%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-number">5.3.5.</span> <span class="nav-text">5.3.5 堆（优先队列）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-6-%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="nav-number">5.3.6.</span> <span class="nav-text">5.3.6 平衡树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-7-%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-number">5.3.7.</span> <span class="nav-text">5.3.7 线段树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-8-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="nav-number">5.3.8.</span> <span class="nav-text">5.3.8 树状数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E6%9F%A5%E6%89%BE%E7%AD%96%E7%95%A5"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 查找策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">5.4.1.</span> <span class="nav-text">5.4.1 二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2-%E5%BF%AB%E9%80%9F%E9%80%89%E5%8F%96"><span class="nav-number">5.4.2.</span> <span class="nav-text">5.4.2 快速选取</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E9%AA%97%E5%88%86"><span class="nav-number">6.</span> <span class="nav-text">6. 骗分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E6%89%93%E8%A1%A8"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 打表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-%E4%BC%90%E6%9C%A8%E5%B7%A5%EF%BC%88%E6%9C%BA%E8%AF%95200%E5%88%86%E9%A2%98%E7%9B%AE%EF%BC%89"><span class="nav-number">6.1.1.</span> <span class="nav-text">6.1.1 伐木工（机试200分题目）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E6%89%BE%E8%A7%84%E5%BE%8B"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 找规律</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Anakin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anakin0607.github.io/%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Anakin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Anakin0607">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="暴力算法 | Anakin0607">
      <meta itemprop="description" content="用暴力->优化的思想解决大部分力扣题">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          暴力算法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-19 14:34:34" itemprop="dateCreated datePublished" datetime="2024-09-19T14:34:34+08:00">2024-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 17:29:12" itemprop="dateModified" datetime="2024-09-26T17:29:12+08:00">2024-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">力扣刷题</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">用暴力->优化的思想解决大部分力扣题</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="1-什么是暴力"><a href="#1-什么是暴力" class="headerlink" title="1.什么是暴力"></a>1.什么是暴力</h1><p>暴力解就是用最直接的方法完成题目要求。类似我们做数学题，先把题目所给条件罗列一下，然后按照题目要求一步步运用条件，不自己加工，也不漏用。</p>
<p>算法考试所有的题目操作都可以分为四部分：</p>
<ol>
<li>读入数据</li>
<li>存储数据</li>
<li>操作数据</li>
<li>输出数据</li>
</ol>
<p>在上一篇文档中已经讲解了输入输出和一些操作数据的基本方法，本篇文档将讲述根据题意，运用上面的操作的方法和选择操作的逻辑。</p>
<p>如：计算1到100的和，暴力解法就是直接计算1 + 2 + 3 + … + 100<br>用代码表示就是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i)&#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而用公式$(1 + 100) * 100 &#x2F; 2$就不叫暴力，因为公式并非根据题意直接得到。<br>或是如：统计数组a &#x3D; [1, 2, 3, 4, 5, 6, 7, 8]中的奇数个数，暴力解法便为，先判断1是不是奇数，1是，然后看2是不是，3是不是。。如此重复下去，直到把整个数组的元素都判断完毕，最终发现共有4个奇数。<br>而直接脱口而出4个，并不是暴力解。</p>
<h1 id="2-暴力解的意义"><a href="#2-暴力解的意义" class="headerlink" title="2. 暴力解的意义"></a>2. 暴力解的意义</h1><h2 id="2-1-降低问题难度"><a href="#2-1-降低问题难度" class="headerlink" title="2.1 降低问题难度"></a>2.1 降低问题难度</h2><p>面对一眼看不出来的思路的问题，通过暴力解可以循序渐进的解决问题。根据上面两个例子，暴力解看似非常机械，单调，重复，麻烦，并不是一个经济的解决问题的办法。但是对于算法考试来说，考试内容是用计算机编程求解问题，而计算机最擅长做的工作，正是上面所说的，重复，单调，麻烦，但是有规律的工作。因此，题目所给出的问题，一定会存在一些重复的，单调的，有规律的地方，（没规律的不重复也没法用代码写）。所以在算法考试中，先利用暴力这一简单，直接的办法去求解问题，往往可以发现问题的规律所在，得到一些启发，再根据规律，对暴力解进行优化，便降低了得到最优解的难度</p>
<h2 id="2-2-平稳考试心态"><a href="#2-2-平稳考试心态" class="headerlink" title="2.2 平稳考试心态"></a>2.2 平稳考试心态</h2><p>除此以外，在考试中，有了暴力解，一道题就不至于0分，对于心态也有一个较强的安抚作用，不至于将自己置于手足无措的境地。</p>
<h2 id="2-3-验证思路"><a href="#2-3-验证思路" class="headerlink" title="2.3 验证思路"></a>2.3 验证思路</h2><p>暴力解通常是对题意最直接的理解以及对思路最简单的表达，如果暴力解正确，可以证明大致思路方向没错。同时在本机运行程序是没有时间和内存限制的，因此可以通过对比暴力解和优化解的答案是否相同，来判断优化解是否正确。</p>
<h1 id="3-书写暴力解的方法"><a href="#3-书写暴力解的方法" class="headerlink" title="3. 书写暴力解的方法"></a>3. 书写暴力解的方法</h1><h2 id="3-1-循环"><a href="#3-1-循环" class="headerlink" title="3.1 循环"></a>3.1 循环</h2><p>如前文所述，算法考试中大部分问题都存在重复的部分，循环又称迭代，是解决重复问题最常用的写法，下面通过几个例题来说明具体如何利用循环书写暴力</p>
<h3 id="3-1-1-两数之和"><a href="#3-1-1-两数之和" class="headerlink" title="3.1.1.两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/description">3.1.1.两数之和</a></h3><p>看看题意，让找两个和为目标值的不同整数，那直接把所有两两不同的都枚举一遍。<br>第一个样例[2, 7, 11 15]<br>按照小学数数方法，先固定第一个，然后和后面三个组合，组合出来(2, 7); (2, 11); (2, 15)，再固定第二个，和后面俩组合得到(7, 11); (7, 15)，再固定第三个，得到(11, 15)，不重不漏，结束了。</p>
<p>让计算机来做这个过程，那就是先搞一层循环，表示第一个固定的数，里面再套一层，来枚举他后面的所有数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; ++j)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i代表第一个变量的下标，j代表第二个变量的下标。</p>
<p>完成枚举之后，题目还需要我们判断，两个数的和是否等于目标值k，这个很好书写，直接用if表达就可以了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[i] + nums[j] == target)</span><br></pre></td></tr></table></figure>
<p>题目还说，只有一种答案，那说明，得到目标解之后，后面的都不用判断了，直接输出俩下标就行了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">    ans[<span class="number">0</span>] = i;</span><br><span class="line">    ans[<span class="number">1</span>] = j;</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后把代码合并一下，就可以提交了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ans = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);<span class="comment">//开辟存储空间，存储答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; ++j)&#123;<span class="comment">//两重循环枚举所有的两个数的组合</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;<span class="comment">//找到符合条件的答案</span></span><br><span class="line">                ans[<span class="number">0</span>] = i;</span><br><span class="line">                ans[<span class="number">1</span>] = j;<span class="comment">//记录答案，返回</span></span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>题目非常直接，暴力解一般可以直接书写，同时此题数据范围也比较小，暴力解可以直接通过。</p>
<h3 id="3-1-2-反转字符串"><a href="#3-1-2-反转字符串" class="headerlink" title="3.1.2.反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/description/">3.1.2.反转字符串</a></h3><p>题目要求是将字符串倒过来，乍一看好像，这还用写代码？反过来就完了呗。那就自己先写两个试试找找规律。<br>0 1 2 3 4 5 6<br>a b c d e f g<br>g f e d c b a</p>
<p>0 1 2 3<br>a b c d<br>d c b a<br>观察发现，C语言中，字符为基本操作单位，那就要从字符的角度观察，每个字符再交换后，到了哪个位置，<br>abcdefg的操作过程为：<br>g b c d e f a<br>g f c d e b a<br>g f e d c b a<br>整个过程为第一个和倒数第一个交换，第二个和倒数第二个交换，直到正数和倒数为同一个数，停止交换。<br>代码写出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lo = <span class="number">0</span>;<span class="comment">//正数下标</span></span><br><span class="line"><span class="type">int</span> hi = sSize - <span class="number">1</span>;<span class="comment">//倒数下标</span></span><br><span class="line"><span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">    swap(&amp;s[lo], &amp;s[hi]);<span class="comment">//逐个交换</span></span><br><span class="line">    lo++;</span><br><span class="line">    hi--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能有些写法会将正数下标写成i，倒数下标写成n - i - 1，我个人认为使用两个变量分别表示正数倒数更加直接，也更不易出错，即该写法更“暴力”，故此处使用lo和hi两个变量来表示。</p>
<p><strong>总结</strong>：此类题目通常为用计算机去模拟日常中看似能够“一步解决”的问题，如例题中的反转字符串，以及练习题中的字符串相加，遇到此类问题不妨耐心动手实践一下，尝试将问题再次分割至更基本的操作，根据更基本的操作，来书写暴力解</p>
<h3 id="3-1-3-车厢重组"><a href="#3-1-3-车厢重组" class="headerlink" title="3.1.3 车厢重组"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1116">3.1.3 车厢重组</a></h3><p>这个题的和上一个题类似，看起来好像更加迷惑了，还是需要一步步操作。<br>仔细阅读题面，抽丝剥茧发现就是，有一个序列，每次只能交换相邻的两个元素，然后任务是对这个玩意进行排序，求需要交换多少次。<br>那我们模拟一下这个过程，是不是很像我们所熟悉的冒泡排序过程呢？只需要增加一个计数器，每次交换元素时，令计数器+1即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10000</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Bubble_count</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j + <span class="number">1</span>] &lt; a[j])&#123;</span><br><span class="line">                swap(&amp;a[j + <span class="number">1</span>], &amp;a[j]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>* a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*MAXN);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = Bubble_count(a, n);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-4-2的幂"><a href="#3-1-4-2的幂" class="headerlink" title="3.1.4 2的幂"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/power-of-two/description/">3.1.4 2的幂</a></h3><p>题目要求判断给定的数x是否为2的幂，正推好像没有什么思路，但是如果给定一个2的次幂$2^k$，我们可以判断，$2^k$这个数是否和x相等，因此问题可以反推解决，即从0开始枚举2的次方，判断是否存在2的k次方和x相等，直到$2^k$大于x时停止枚举。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//负数肯定不是</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; i) == n)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结:</strong> 有些问题难以直接求解，但较易验证一个答案是否为问题的解，此类问题可以通过<strong>枚举答案-&gt;验证</strong>的方法进行解答。</p>
<h3 id="3-1-4-其他习题"><a href="#3-1-4-其他习题" class="headerlink" title="3.1.4 其他习题"></a>3.1.4 其他习题</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/description/">力扣14. 最长公共前缀</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-average-subarray-i/description/">力扣643. 子数组最大平均数</a><br><strong>提示：</strong> 可以先不管题解，直接练习暴力，每次取5个，计算平均数，然后留下最大值，题解方法如何由暴力得到后面会有讲解<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/">力扣2529. 正整数和负整数的最大计数</a><br><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1428">洛谷P1428 小鱼比可爱</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-strings/description/">力扣415. 字符串相加</a><br><strong>提示：</strong> 先试试列竖式计算，然后用代码实现这个过程即可<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/">力扣1011. D天内送达包裹的能力</a><br><strong>提示：</strong> 直接求天数确实不好求，但是可以先验证此问题：“若每天运送的能力为k的，包裹是否能在days天内送完？”，再观察答案，显然若运送能力无限，包裹肯定能送达，因此可以从包裹里面的最小值开始枚举答案，直到答案合法为止，即可以得到问题答案。<br>此题可利用二分法优化，后面会进行讲解<br><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1089">洛谷P1089 津津的储蓄计划</a></p>
<h2 id="3-2-递归"><a href="#3-2-递归" class="headerlink" title="3.2 递归"></a>3.2 递归</h2><p>问题中重复的部分，有时用递归更方便表达，同时，递归和迭代之间，也可以相互转换。</p>
<h3 id="3-2-1-斐波那契数列"><a href="#3-2-1-斐波那契数列" class="headerlink" title="3.2.1 斐波那契数列"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1962">3.2.1 斐波那契数列</a></h3><p>题目要求求出斐波那契数列第n项的值，那我们可以定义一个函数，其返回斐波那契数列第n项的值，按照题意直接写就完了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目中要求取模，那返回的时候再取个模就完事。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, fib(n)%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码肯定是没法通过的，但在一定数据范围内可以得到正确答案，对于较大的数据量，暴力解法通常只能得到部分正确答案，但不能在规定用时和空间内得到所有正确答案，原因以及优化方法在后面会有讲解。<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-th-tribonacci-number/description/">想通过可以试试这个</a></p>
<h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><p>暴力就是使用最直接的办法去利用题目条件解决问题。通常有三类问题，第一类问题可直接根据题意进行表达，第二类问题为用计算机去模拟一些看似简单的人工操作，此类问题需要一定的耐心，去分解这些日常中看似“一步完成”的问题，最后一类问题通常难以直接求解，但较易验证一个答案是否为合法解，此类问题可以通过枚举答案然后验证来得到问题的最终解。</p>
<h1 id="4-高级暴力"><a href="#4-高级暴力" class="headerlink" title="4. 高级暴力"></a>4. 高级暴力</h1><p>面对一些较为复杂的问题，直接求解通常较为困难，但是可以先将大问题划分为一些规模较小，较为简易的问题，再对这些简单的问题逐个进行求解，便可做到“大事化小，小事化了”。但这些简单问题也不一定能一次求解，还可能需要继续划分，这时我们需要及时判断，这种划分方法是否能有效的得到问题的解。下面将讲述一些划分方法和一些判断方法。</p>
<h2 id="4-1-减而治之"><a href="#4-1-减而治之" class="headerlink" title="4.1 减而治之"></a>4.1 减而治之</h2><p>有些问题，我们可以通过将问题分割为一个能够暴力解决的问题（称为平凡情况），和一个规模小于原问题，但和原问题相同的子问题的方法划分，不难证明，如此一直对每次划分出的子问题进行上面的操作，总会有一次划分，将子问题的规模减小至平凡解。<br>就好比我们想将一串珠子拆开，只需每次取下一个珠子，就可以得到一个单个的珠子和比原来珠子少一个的一串珠子，然后不断重复这个过程，最后将会的到一个绳子和一堆单个珠子。<br>-0000000000-<br>–000000000-   0<br>—00000000-   0 0<br>……<br>-————-0- 0 0 0 0 0 0 0 0 0<br>-—————-   0 0 0 0 0 0 0 0 0 0</p>
<p>因此，可以将问题划分成一个规模小于原问题，但类型和原问题相同的问题（称作子问题），加上一个可以直接暴力解决的问题的划分方法，可以的得到问题的解。</p>
<h3 id="例1：反转字符串"><a href="#例1：反转字符串" class="headerlink" title="例1：反转字符串"></a>例1：反转字符串</h3><p>前文提到的反转字符串问题:</p>
<blockquote>
<p>给定一个字符串abcdefg，输出反转之后的字符串。</p>
</blockquote>
<p>这个问题似乎不好直接解决，但是可以这样考虑一下：<br>对于一个长度为n的字符串，表示为S[0, n)，进行如下操作：</p>
<ol>
<li>交换S[0]和S[n - 1]</li>
<li>反转S[1, n - 1)<br>如此迭代，直至S中只剩下0个或1个元素。<br>其中交换两个元素的过程，是可以直接暴力解决的问题，而反转字符串S[1, n - 1)，则是一个和原问题相同的，但规模更小的子问题，不难证明，如此迭代下去，问题规模会不断削减直至平凡情况。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse_str</span><span class="params">(<span class="type">char</span>* str, <span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;<span class="comment">//反转str[lo, hi)</span></span><br><span class="line">    <span class="keyword">if</span>(hi - lo &lt;= <span class="number">1</span>)&#123;<span class="comment">//如果就剩下一个元素或者没有元素</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(str[lo], str[hi - <span class="number">1</span>]);</span><br><span class="line">    Reverse_str(str, lo + <span class="number">1</span>, hi - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="例2：选择排序"><a href="#例2：选择排序" class="headerlink" title="例2：选择排序"></a>例2：选择排序</h3><p>对于排序问题，直接做并不好做，但是可以通过暴力从数组中选出一个最小值，将其放在第一个位置上，这样，数组的第一个位置便成了有序的，然后只需再对后面的序列进行排序，如此迭代，直至所有元素都被选出，便得到了一个有序的序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Select_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;<span class="comment">//将数组中下标[lo, hi)范围的序列排序</span></span><br><span class="line">    <span class="keyword">if</span>(hi - lo &lt; <span class="number">2</span>) <span class="keyword">return</span>;<span class="comment">//一个元素就是有序的</span></span><br><span class="line">    <span class="comment">//先默认最开始的元素是最小的，然后和后面的逐个比较</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = lo + <span class="number">1</span>; i &lt; hi; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; a[lo]) </span><br><span class="line">            swap(&amp;a[i], &amp;a[lo]);</span><br><span class="line">    &#125;</span><br><span class="line">    Select(a, lo + <span class="number">1</span>, hi);<span class="comment">//lo位置处的元素已经在正确位置，排序后面即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例3：汉诺塔问题"><a href="#例3：汉诺塔问题" class="headerlink" title="例3：汉诺塔问题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/hanota-lcci/description/">例3：汉诺塔问题</a></h3><p>先<a target="_blank" rel="noopener" href="https://zhangxiaoleiwk.gitee.io/h.html">玩玩这个小游戏</a>一下感受一下，看看能不能发现什么规律。<br>每次只能挪一个片片，还得上小下大，所以对于一个高度为n的塔，想挪掉最下面的片片，必须得挪掉最上面的n-1个片片，而因为必须上小下大，上面n-1个片也只有高度为n-1的塔这样一种排布方式。<br>所以这样问题的步骤可以分为：</p>
<ol>
<li>先把上面高度为n-1的塔挪到中间的柱子上</li>
<li>把最大的片片挪到最后一根柱子上，</li>
<li>把中间柱子上高度为n - 1的塔挪到最后一根柱子上<br>第一步和第三步，都是和原问题相同，但是规模更小的问题，第二步可以一步暴力解决，这个方法一定能得到问题的解。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hano</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span>* ASize, <span class="type">int</span>* B, <span class="type">int</span>* BSize, <span class="type">int</span>* C, <span class="type">int</span>* CSize, <span class="type">int</span> n)</span>&#123;<span class="comment">//把A塔上的最上面高度为n的塔，借助B挪到C上</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;<span class="comment">//有一个盘子，则可以直接挪</span></span><br><span class="line">        C[(*CSize)++] = A[--(*ASize)];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//多于一个盘子</span></span><br><span class="line">    hano(A, ASize, C, CSize, B, BSize, n - <span class="number">1</span>);<span class="comment">//先把A最上面的n - 1个挪到B上</span></span><br><span class="line">    hano(A, ASize, B, BSize, C, CSize, <span class="number">1</span>);<span class="comment">//此时A塔上还剩下一个，就把这一个挪到C塔上</span></span><br><span class="line">    hano(B, BSize, A, ASize, C, CSize, n - <span class="number">1</span>);<span class="comment">//再把刚才挪到B上面的前面n - 1挪到C上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//待实现函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hanota</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> ASize, <span class="type">int</span>* B, <span class="type">int</span> BSize, <span class="type">int</span>** C, <span class="type">int</span>* CSize)</span>&#123;</span><br><span class="line">    B = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*ASize);</span><br><span class="line">    *C = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*ASize);</span><br><span class="line">    BSize = <span class="number">0</span>;</span><br><span class="line">    *CSize = <span class="number">0</span>;</span><br><span class="line">    hano(A, &amp;ASize, B, &amp;BSize, *C, CSize, ASize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="例4-全排列"><a href="#例4-全排列" class="headerlink" title="例4:全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">例4:全排列</a></h3><p>这个问题看起来更加复杂了，但是耐心观察，依然可以利用减而治之的方法解决。<br>首先，只有一个数字的全排列只有一种，显然可以暴力解决。<br>对于多于一个数的序列，假设有n个数，那么只需要轮流将每个数放在第一位，找出其他元素的全排列即可。<br>在寻找其他元素的全排列过程中，依然可以按照上面的方法解决。<br>例如：序列{1,2,3}</p>
<ol>
<li>将1放在第一位，作为排列的首元素</li>
<li>找出序列{2, 3}的全排列，放在1后面</li>
<li>再将2放在第一位，作为首元素</li>
<li>找出序列{1, 3}的全排列，放在2后面</li>
<li>将3放在第一位，作为首元素</li>
<li>找出{1, 2}的全排列，放在3后面</li>
</ol>
<p>如此不难发现，问题规模会不断减小，直至平凡情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Get_permute</span><span class="params">(<span class="type">int</span>* state, <span class="type">int</span> len, <span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* vis, <span class="type">int</span>**res, <span class="type">int</span>* resSize)</span>&#123;</span><br><span class="line">    <span class="comment">//函数意义为，从nums中选取可选择的元素，生成一个长度为target的全排列，放置在state[len]开始的位置上。在本题中，target可以由numsSize - len得到，故省略</span></span><br><span class="line">    <span class="comment">//state为已经生成的排列，nums为待生成排序的序列， vis表示第[i]个数是否可以被选择， numSize为共有多少个数，len为已生成的排列长度，res为结果，resSize为每个结果的长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;, len);</span></span><br><span class="line">    <span class="keyword">if</span>(numsSize - target == <span class="number">0</span>)&#123;<span class="comment">//已经生成了达标的序列，把答案存下来</span></span><br><span class="line">        <span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            temp[i] = state[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;, returnSize)</span></span><br><span class="line">        res[(*resSize)++] = temp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;<span class="comment">//逐个选择不在序列中的元素作为当前排列的第一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;<span class="comment">//如果可以选择</span></span><br><span class="line">            vis[i] = <span class="number">1</span>;<span class="comment">//后面不能再选这个数了</span></span><br><span class="line">            state[len] = nums[i];<span class="comment">//把这个数放在len处，作为当前待生成排列的第一个数</span></span><br><span class="line">            Get_permute(state, len+<span class="number">1</span>, nums, numsSize, vis, res, resSize);<span class="comment">//生成后面没选的数的全排列</span></span><br><span class="line">            vis[i] = <span class="number">0</span>;<span class="comment">//下次可以继续用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>** <span class="title function_">permute</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span> &#123;</span><br><span class="line">    <span class="type">int</span>** ans = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)* <span class="number">1000</span>);</span><br><span class="line">    <span class="type">int</span>* state = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span>* vis = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) vis[i] = <span class="number">0</span>;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* ret_col = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">1000</span>);</span><br><span class="line">    Get_permute(state, <span class="number">0</span>, nums, numsSize, vis, ans, returnSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; *returnSize; ++i) ret_col[i] = numsSize;</span><br><span class="line">    *returnColumnSizes = ret_col;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中借助了标记数组vis来表示每个数是否已经在排列中。</p>
<h2 id="4-2-分而治之"><a href="#4-2-分而治之" class="headerlink" title="4.2 分而治之"></a>4.2 分而治之</h2><p>对于某些问题，可以将其分解成两个或者多个和原问题相同，但规模小于原问题的子问题，然后将子问题再分，直至出现平凡情况，之后再通过合并子问题的解，最终得到整个问题的解。此种解决问题的方法叫做分而治之。<br>就好比我们想把一张纸撕成16片，我们也可以先把他撕成均匀的两片，这样就可以得到两张纸，然后我们只需要把这两张纸每一张都撕成八片即可，问题本身还是撕纸，但是规模减小了一半，之后可以再将得到的两片纸各撕成两半，那现在就得到了四片，现在只需将每片撕成四片即可。再分两次，发现已经是16片了，每片纸不需要再分，问题解决。</p>
<h3 id="例1-归并排序"><a href="#例1-归并排序" class="headerlink" title="例1.归并排序"></a>例1.归并排序</h3><p>没错又是排序。但是这次采取了不同的暴力算法和分割问题的方法。<br>先来看下面的一个问题：</p>
<blockquote>
<p>给出两个有序序列A（长度为n）和B（长度为m），将A和B合并成一个有序序列<br>样例输入：<br>5<br>1 3 5 7 9<br>4<br>2 4 6 8<br>样例输出：<br>1 2 3 4 5 6 7 8 9</p>
</blockquote>
<p>这个问题好像比较简单，新开一个空间，每次从两个序列里面选小的放进去就好了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> aSize, <span class="type">int</span>* b, <span class="type">int</span> bSize)</span>&#123;<span class="comment">//把有序序列a,b合并，首元素地址放在a中，并以归并后的长度作为返回值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-搜索"><a href="#4-3-搜索" class="headerlink" title="4.3 搜索"></a>4.3 搜索</h2><h2 id="4-4-动态规划（记忆化搜索）"><a href="#4-4-动态规划（记忆化搜索）" class="headerlink" title="4.4 动态规划（记忆化搜索）"></a>4.4 动态规划（记忆化搜索）</h2><h1 id="5-优化暴力解的方法"><a href="#5-优化暴力解的方法" class="headerlink" title="5. 优化暴力解的方法"></a>5. 优化暴力解的方法</h1><h2 id="5-1-评估指标"><a href="#5-1-评估指标" class="headerlink" title="5.1 评估指标"></a>5.1 评估指标</h2><p>在考试中，题目数据范围不同，需要采用的算法就不同。因此我们需要根据题目要求和范围，来确定优化程序的方法和程度，尽可能做到在拿到力所能及的分数的同时，避免“杀鸡用牛刀”，造成时间的浪费。</p>
<h3 id="5-1-1-时间复杂度"><a href="#5-1-1-时间复杂度" class="headerlink" title="5.1.1 时间复杂度"></a>5.1.1 时间复杂度</h3><p>通常情况下，计算机主频为GHz级别，即1秒钟能执行$10^9$次运算，大部分考试程序运行限时都为1s，考虑到复杂度的常数影响，算法复杂度和在1s内能处理数据范围如下表所示</p>
<table>
<thead>
<tr>
<th>算法复杂度</th>
<th>在1s内能处理的数据范围</th>
</tr>
</thead>
<tbody><tr>
<td>$O(1)$</td>
<td>任何问题</td>
</tr>
<tr>
<td>$O(log(n))$</td>
<td>几乎任何问题</td>
</tr>
<tr>
<td>$O(n)$</td>
<td>$n &lt;&#x3D; 10^7$</td>
</tr>
<tr>
<td>$O(nlog(n))$</td>
<td>$n &lt;&#x3D; 10^5$</td>
</tr>
<tr>
<td>$O(n^2)$</td>
<td>$n &lt;&#x3D; 5000$</td>
</tr>
<tr>
<td>$O(n^3)$</td>
<td>$n &lt;&#x3D; 500$</td>
</tr>
<tr>
<td>$O(2^n)$</td>
<td>$n &lt;&#x3D; 50$</td>
</tr>
</tbody></table>
<p>根据上述经验，大概可以判断算法是否需要继续优化，如题目中范围只有50，任何暴力解法只要给出正确答案，都可以拿到满分，但是若数据量在$10^3$数量级，需要考虑$O(n^2)$的算法，也就是使用两层循环，就可以拿到全部分数，但是也不需要再优化到一重循环。<br><strong>切记：</strong> 在限定时间内得到规定答案即可，快了没有更多的分数，但是优化有风险，既耗费考试时间，又可能出错，因此完全没必要过度优化程序。</p>
<h3 id="5-1-2-空间复杂度"><a href="#5-1-2-空间复杂度" class="headerlink" title="5.1.2 空间复杂度"></a>5.1.2 空间复杂度</h3><p>由于时间复杂度为空间复杂度的天然上界（每使用一个单位的空间，都需要对这个空间进行操作，即要耗费$O(1)$的时间），因此通常题目对空间的要求较低，根据数据范围分配空间，基本都不会出问题。<br>若看到对空间复杂度有特殊要求的题目，谨慎使用递归！</p>
<h2 id="5-2-去重"><a href="#5-2-去重" class="headerlink" title="5.2 去重"></a>5.2 去重</h2><p>过于直接的暴力解，通常会有许多重复计算。通过仔细观察每次计算过程，发现重复部分，通过记忆，提前结束循环等方式减少重复，便可优化暴力解。</p>
<h3 id="4-2-1-子数组最大平均数"><a href="#4-2-1-子数组最大平均数" class="headerlink" title="4.2.1 子数组最大平均数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-average-subarray-i/description/">4.2.1 子数组最大平均数</a></h3><p>如果按照最直接的方法，会写出如下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> ans = <span class="number">-1e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize - k - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++j)&#123;<span class="comment">//每次取k个计算</span></span><br><span class="line">        sum += nums[i + j];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = fmax(ans, (<span class="type">double</span>)sum/k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是仔细观察可以发现，假设k为3，则第一轮的计算值为$a_0 + a_1 + a_2$，第二轮的计算值为$a_1 + a_2 + a_3$，不难发现，两个值的改变只有$a_0$和$a_3$，其中$a_1 + a_2$的值并不需要重新计算，同时根据题意，取平均值的最大值，由平均值计算公式可知，当k个数的和最大时，平均值也最大，因此每次除以k的操作也没有必要进行，故不妨将代码优化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">findMaxAverage</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;<span class="comment">//先算前k个</span></span><br><span class="line">    <span class="type">int</span> ans = sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; numsSize; ++i)&#123;<span class="comment">//不断往后挪，去掉第一个，加上当前的</span></span><br><span class="line">        sum -= nums[i - k];<span class="comment">//减去最前面的</span></span><br><span class="line">        sum += nums[i];<span class="comment">//加上一个新的</span></span><br><span class="line">        ans = fmax(sum, ans);<span class="comment">//记录大的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)ans/k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经以上优化，时间复杂度由$O(nk)$变为$O(n)$，大幅度减小，效果显著</p>
<h3 id="4-2-2查找总价格为目标值的商品"><a href="#4-2-2查找总价格为目标值的商品" class="headerlink" title="4.2.2查找总价格为目标值的商品"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/">4.2.2查找总价格为目标值的商品</a></h3><p>此题暴力思路和两数之和类似，都是两重循环枚举。但是有一个额外条件，就是数据有序，那么在枚举的时候，如果枚举到$(price_i + price_j) &gt; target$，那么说明i和j后面的其他元素相加也会大于target，故可以直接排除后面的所有情况。<br>因此可以优化如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; priceSize; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; priceSize; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(price[i] + price[j] == target)&#123;</span><br><span class="line">            ans[<span class="number">0</span>] = price[i];</span><br><span class="line">            ans[<span class="number">1</span>] = price[j];</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(price[i] + price[j] &gt; target) <span class="keyword">break</span>;<span class="comment">//大于则不再找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个优化之后虽然对平均情况下时间复杂度没有数量级上的改变，都是$O(n^2)$，但也有一定程度的优化，在考试中可能可以多过几个点。</p>
<h2 id="5-3-数据结构"><a href="#5-3-数据结构" class="headerlink" title="5.3 数据结构"></a>5.3 数据结构</h2><p>数据结构可以按一定的顺序组织数据，并且高效的实现某些操作。<br>此处不再花费篇幅去介绍数据结构的逻辑性质和数学推理证明，而通过对某些有特定性质的数据，提出一些问题，然后逐步解决这些问题，去逐步书写代码。</p>
<h3 id="5-3-1-栈和队列"><a href="#5-3-1-栈和队列" class="headerlink" title="5.3.1 栈和队列"></a>5.3.1 栈和队列</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>现在要设计一个满足如下功能的序列容器。其有两个操作：</p>
<ol>
<li>向序列中加入一个元素</li>
<li>返回最新加入的元素的值，并将元素从这个序列中删除</li>
</ol>
<p>看到问题，按照前面解决问题的思路，先读入然后存储数据。因为要存储一个序列，可以考虑使用数组来存储。由于不知道要加入多少个元素，因此可以采用前文中复制字符串的cnt策略，每次加入元素时这个计数器+1，其既表示了容器中元素的个数，同时也代表了加入元素时写入的位置。删除时，令计数器-1，然后读取结果即可。</p>
<p>由于这种操作看起来非常像，每次将物体放到容器顶端，然后需要取的时候，从顶端取出（想象一下刷盘子的时候），因此这个计数器命名为top。<br>这种容器就被命名为栈，top又称栈顶。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span>* top, <span class="type">int</span> x)</span>&#123;<span class="comment">//S是容器数组，top是栈顶指针，此处用两种写法方便区分，x为待加入元素</span></span><br><span class="line">    S[(*top)] = x;</span><br><span class="line">    (*top)++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span>* top)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = S[(*top) - <span class="number">1</span>];<span class="comment">//返回栈顶元素</span></span><br><span class="line">    *(top)--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例1：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/asteroid-collision/description/?envType=list&envId=CMcRiC2r">小行星碰撞</a></strong><br><strong>例2：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-strings/description/?envType=list&envId=CMcRiC2r">415.字符串相加</a></strong><br><strong>例3：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/multiply-strings/description/?envType=list&envId=CMcRiC2r">43.字符串相乘</a></strong></p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是满足下面功能的序列容器，其也有两个操作：</p>
<ol>
<li>向容器中加入元素</li>
<li>取出容器中最早加入的元素</li>
</ol>
<h3 id="5-3-2-链表"><a href="#5-3-2-链表" class="headerlink" title="5.3.2 链表"></a>5.3.2 链表</h3><h3 id="5-3-3-树"><a href="#5-3-3-树" class="headerlink" title="5.3.3 树"></a>5.3.3 树</h3><h3 id="5-3-4-图"><a href="#5-3-4-图" class="headerlink" title="5.3.4 图"></a>5.3.4 图</h3><h3 id="5-3-5-堆（优先队列）"><a href="#5-3-5-堆（优先队列）" class="headerlink" title="5.3.5 堆（优先队列）"></a>5.3.5 堆（优先队列）</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/description/">例题：239.滑动窗口最大值</a></p>
<h3 id="5-3-6-平衡树"><a href="#5-3-6-平衡树" class="headerlink" title="5.3.6 平衡树"></a>5.3.6 平衡树</h3><h3 id="5-3-7-线段树"><a href="#5-3-7-线段树" class="headerlink" title="5.3.7 线段树"></a>5.3.7 线段树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fancy-sequence/description/">例题：1622.奇妙序列</a></p>
<h3 id="5-3-8-树状数组"><a href="#5-3-8-树状数组" class="headerlink" title="5.3.8 树状数组"></a>5.3.8 树状数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/description/">例题：307.区域和检索-数组可修改</a></p>
<h2 id="5-4-查找策略"><a href="#5-4-查找策略" class="headerlink" title="5.4 查找策略"></a>5.4 查找策略</h2><h3 id="5-4-1-二分查找"><a href="#5-4-1-二分查找" class="headerlink" title="5.4.1 二分查找"></a>5.4.1 二分查找</h3><h3 id="5-4-2-快速选取"><a href="#5-4-2-快速选取" class="headerlink" title="5.4.2 快速选取"></a>5.4.2 快速选取</h3><h1 id="6-骗分"><a href="#6-骗分" class="headerlink" title="6. 骗分"></a>6. 骗分</h1><p>考试如果遇到实在解不出来的部分，我们不能心甘情愿的就放弃，能争取还是需要争取一下的，骗分一定切记，不能贪多，因为反正我不会，拿一分我赚一分</p>
<h2 id="6-1-打表"><a href="#6-1-打表" class="headerlink" title="6.1 打表"></a>6.1 打表</h2><h3 id="6-1-1-伐木工（机试200分题目）"><a href="#6-1-1-伐木工（机试200分题目）" class="headerlink" title="6.1.1 伐木工（机试200分题目）"></a>6.1.1 伐木工（机试200分题目）</h3><p><strong>题目描述</strong></p>
<blockquote>
<p>一根x米长的树木，伐木工切割成不同长度的木材进行交易，交易价格为每根木头长度的乘积，规定切割后每根木头的长度为正整数，也可以不切割，直接拿整根数目进行交易，请问伐木工如何更少的切割，才能使收益最大化?<br><strong>输入描述：</strong> 木材长度x(x&lt;&#x3D;50)<br><strong>输出描述:</strong> 切割方案，以空格分割，升序排列<br><strong>样例输入：</strong> 10<br><strong>样例输出：</strong> 3 3 4</p>
</blockquote>
<p>看完题目之后，这好像短时间内不好写，但是观察一下，确实有白送的分<br>显然长度为1，2，3都不用切割，4可以切成2*2也可以不切，因为要求尽可能少切，所以4也不用切<br>5切成2和3，6切成3和3，7切成3和4<br>8好像就不太好算了，是2，3，3，不算那么白送了，如果还有别的题没做，那就先写前面的代码，拿到白送的分，然后看其他题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(x)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-找规律"><a href="#6-2-找规律" class="headerlink" title="6.2 找规律"></a>6.2 找规律</h2>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
              <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BA%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/" rel="prev" title="从源码构建树莓派系统镜像">
                  <i class="fa fa-angle-left"></i> 从源码构建树莓派系统镜像
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/C%E8%AF%AD%E8%A8%80%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="next" title="C语言刷题基础知识">
                  C语言刷题基础知识 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Anakin</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>


  





</body>
</html>
